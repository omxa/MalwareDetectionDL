
#This is the main function of the PE classification of this program

#In this program we are first extracting the features from the PE and then providing it to the saved machine and using thoses features we are prediciting whether the PE is malicious or not.

import pefile
import os
import array
import math
import pickle
import joblib
import sys
import argparse


#For calculating the entropy
def get_entropy(data):
    if len(data) == 0:
        return 0.0
    occurences = array.array('L', [0]*256)
    for x in data:
        occurences[x if isinstance(x, int) else ord(x)] += 1

    entropy = 0
    for x in occurences:
        if x:
            p_x = float(x) / len(data)
            entropy -= p_x*math.log(p_x, 2) #Shannon's entropy formula

    return entropy

#For extracting the resources part
def get_resources(pe):
    """Extract resources :
    [entropy, size]"""
    resources = []
    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        try:
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'directory'):
                            for resource_lang in resource_id.directory.entries:
                                data = pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
                                size = resource_lang.data.struct.Size
                                entropy = get_entropy(data)

                                resources.append([entropy, size])
        except Exception as e:
            return resources
    return resources

#For getting the version information
def get_version_info(pe):
    """Return version infos"""
    res = {}
    for fileinfo in pe.FileInfo:
        if fileinfo.Key == 'StringFileInfo':
            for st in fileinfo.StringTable:
                for entry in st.entries.items():
                    res[entry[0]] = entry[1]
        if fileinfo.Key == 'VarFileInfo':
            for var in fileinfo.Var:
                res[var.entry.items()[0][0]] = var.entry.items()[0][1]
    if hasattr(pe, 'VS_FIXEDFILEINFO'):
          res['flags'] = pe.VS_FIXEDFILEINFO.FileFlags
          res['os'] = pe.VS_FIXEDFILEINFO.FileOS
          res['type'] = pe.VS_FIXEDFILEINFO.FileType
          res['file_version'] = pe.VS_FIXEDFILEINFO.FileVersionLS
          res['product_version'] = pe.VS_FIXEDFILEINFO.ProductVersionLS
          res['signature'] = pe.VS_FIXEDFILEINFO.Signature
          res['struct_version'] = pe.VS_FIXEDFILEINFO.StrucVersion
    return res


'''def extract_pe_features(file_path):
    features = []
    pe = pefile.PE(file_path)
    features.append(pe.FILE_HEADER.Machine)
    features.append(pe.FILE_HEADER.SizeOfOptionalHeader)
    features.append(pe.FILE_HEADER.Characteristics)
    features.append(pe.OPTIONAL_HEADER.MajorLinkerVersion)
    features.append(pe.OPTIONAL_HEADER.MinorLinkerVersion)
    features.append(pe.OPTIONAL_HEADER.SizeOfCode)
    features.append(pe.OPTIONAL_HEADER.SizeOfInitializedData)
    features.append(pe.OPTIONAL_HEADER.SizeOfUninitializedData)
    features.append(pe.OPTIONAL_HEADER.AddressOfEntryPoint)
    features.append(pe.OPTIONAL_HEADER.BaseOfCode)
    try:
        features.append(pe.OPTIONAL_HEADER.BaseOfData)
    except AttributeError:
        features.append(0)
    features.append(pe.OPTIONAL_HEADER.ImageBase)
    features.append(pe.OPTIONAL_HEADER.SectionAlignment)
    features.append(pe.OPTIONAL_HEADER.FileAlignment)
    features.append(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion)
    features.append(pe.OPTIONAL_HEADER.MinorOperatingSystemVersion)
    features.append(pe.OPTIONAL_HEADER.MajorImageVersion)
    features.append(pe.OPTIONAL_HEADER.MinorImageVersion)
    features.append(pe.OPTIONAL_HEADER.MajorSubsystemVersion)
    features.append(pe.OPTIONAL_HEADER.MinorSubsystemVersion)
    features.append(pe.OPTIONAL_HEADER.SizeOfImage)
    features.append(pe.OPTIONAL_HEADER.SizeOfHeaders)
    features.append(pe.OPTIONAL_HEADER.CheckSum)
    features.append(pe.OPTIONAL_HEADER.Subsystem)
    features.append(pe.OPTIONAL_HEADER.DllCharacteristics)
    features.append(pe.OPTIONAL_HEADER.SizeOfStackReserve)
    features.append(pe.OPTIONAL_HEADER.SizeOfStackCommit)
    features.append(pe.OPTIONAL_HEADER.SizeOfHeapReserve)
    features.append(pe.OPTIONAL_HEADER.SizeOfHeapCommit)
    features.append(pe.OPTIONAL_HEADER.LoaderFlags)
    features.append(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes)

    # Sections
    features.append(len(pe.sections))
    entropy = list(map(lambda x: x.get_entropy(), pe.sections))
    features.append(sum(entropy) / float(len((entropy))))
    features.append(min(entropy))
    features.append(max(entropy))
    raw_sizes = list(map(lambda x: x.SizeOfRawData, pe.sections))
    features.append(sum(raw_sizes) / float(len((raw_sizes))))
    features.append(min(raw_sizes))
    features.append(max(raw_sizes))
    virtual_sizes = list(map(lambda x: x.Misc_VirtualSize, pe.sections))
    features.append(sum(virtual_sizes) / float(len(virtual_sizes)))
    features.append(min(virtual_sizes))
    features.append(max(virtual_sizes))

    # Imports
    try:
        features.append(len(pe.DIRECTORY_ENTRY_IMPORT))
        imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
        features.append(len(imports))
        features.append(0)
    except AttributeError:
        features.append(0)
        features.append(0)
        features.append(0)

    # Exports
    try:
        features.append(len(pe.DIRECTORY_ENTRY_EXPORT.symbols))
    except AttributeError:
        features.append(0)

    # Resources
    resources = get_resources(pe)
    features.append(len(resources))
    if len(resources) > 0:
        entropy = list(map(lambda x: x[0], resources))
        features.append(sum(entropy) / float(len(entropy)))
        features.append(min(entropy))
        features.append(max(entropy))
        sizes = list(map(lambda x: x[1], resources))
        features.append(sum(sizes) / float(len(sizes)))
        features.append(min(sizes))
        features.append(max(sizes))
    else:
        features.extend([0, 0, 0, 0, 0, 0, 0])

    # Load configuration size
    try:
        features.append(pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size)
    except AttributeError:
        features.append(0)

    # Version configuration size
    try:
        version_infos = get_version_info(pe)
        features.append(len(version_infos.keys()))
    except AttributeError:
        features.append(0)

    return features'''



#extract the info for a given file using pefile
def extract_pe_features(fpath):
    res = {}
    pe = pefile.PE(fpath)
    res['Machine'] = pe.FILE_HEADER.Machine
    res['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
    res['Characteristics'] = pe.FILE_HEADER.Characteristics
    res['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
    res['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
    res['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
    res['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
    res['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
    res['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    res['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
    try:
        res['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData
    except AttributeError:
        res['BaseOfData'] = 0
    res['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
    res['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
    res['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
    
    return res





if __name__ == '__main__':
    
    #Loading the pe_classifier.pkl and pe_features.pkl
    clf = joblib.load('Classifier/pe_classifier.pkl')
    features = pickle.loads(open(os.path.join('Classifier/pe_features.pkl'),'rb').read())
    
    #extracting features from the PE file mentioned in the argument 
    data = extract_pe_features(sys.argv[1])
    
    #matching it with the features saved in features.pkl
    pe_features = list(map(lambda x:data[x], features))
    print("Features used for classification: ", pe_features)
    
    #prediciting if the PE is malicious or not based on the extracted features
    res= clf.predict([pe_features])[0]
    print ('The file %s is %s' % (os.path.basename(sys.argv[1]),['malicious', 'legitimate'][res]))








    